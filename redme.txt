OK, nickel, on va poser **une vraie structure de projet** propre avant dâ€™Ã©crire une seule ligne de code.
On suit bien le dÃ©roulÃ© du PDF RSA (gÃ©nÃ©ration des clÃ©s, chiffrement, dÃ©chiffrement, ASCIIâ€¦) 

---

## 1. Arborescence gÃ©nÃ©rale du projet

Je te propose un projet comme Ã§a :

```text
rsa_reseau/
â”‚
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ rsa_core.py          # Toute la logique RSA (maths, clÃ©s, chiffrement, dÃ©chiffrement)
â”‚   â””â”€â”€ net_utils.py         # Fonctions rÃ©seau communes (envoi/rÃ©ception fiable)
â”‚
â”œâ”€â”€ alice/
â”‚   â”œâ”€â”€ alice_keys.py        # GÃ©nÃ©ration & sauvegarde des clÃ©s dâ€™Alice
â”‚   â”œâ”€â”€ alice_encrypt.py     # Fonctions de chiffrement/dÃ©chiffrement cÃ´tÃ© Alice
â”‚   â”œâ”€â”€ alice_client.py      # Programme client pour envoyer un message Ã  Bob
â”‚   â”œâ”€â”€ alice_server.py      # Programme serveur pour recevoir des messages de Bob
â”‚   â”œâ”€â”€ alice_public.key     # FICHIER clÃ© publique dâ€™Alice (n, e)
â”‚   â””â”€â”€ alice_private.key    # FICHIER clÃ© privÃ©e dâ€™Alice (n, u)
â”‚
â””â”€â”€ bob/
    â”œâ”€â”€ bob_keys.py          # GÃ©nÃ©ration & sauvegarde des clÃ©s de Bob
    â”œâ”€â”€ bob_encrypt.py       # Fonctions de chiffrement/dÃ©chiffrement cÃ´tÃ© Bob
    â”œâ”€â”€ bob_client.py        # Programme client pour envoyer un message Ã  Alice
    â”œâ”€â”€ bob_server.py        # Programme serveur pour recevoir des messages dâ€™Alice
    â”œâ”€â”€ bob_public.key       # FICHIER clÃ© publique de Bob (n, e)
    â””â”€â”€ bob_private.key      # FICHIER clÃ© privÃ©e de Bob (n, u)
```

* **`common/`** : tout ce qui est partagÃ© (maths RSA, fonctions rÃ©seau).
* **`alice/`** : tout ce qui est spÃ©cifique Ã  Alice (ses fichiers de clÃ©s, ses programmes).
* **`bob/`** : pareil pour Bob.

---

## 2. Contenu des modules

### 2.1. `common/rsa_core.py`

Câ€™est le cÅ“ur du RSA, commun aux deux :

* `generate_keys(bits)`

  * gÃ©nÃ¨re `p`, `q`, calcule `n`, `m`, choisit `e`, calcule `u` (Euclide Ã©tendu)
  * renvoie `(n, e)` et `(n, u)`

* `encrypt_int(m, n, e)` â†’ `c = m^e mod n`

* `decrypt_int(c, n, u)` â†’ `m = c^u mod n`

* Fonctions pour gÃ©rer le texte comme dans le PDF :

  * `text_to_int_list(message)` â†’ liste dâ€™entiers (ASCII)
  * `int_list_to_text(lst)` â†’ texte

Tu restes trÃ¨s proche des sections 2â€“5 du sujet (crÃ©ation des clÃ©s, chiffrement, dÃ©chiffrement) 

---

### 2.2. `common/net_utils.py`

Quelques petites fonctions utilitaires pour le rÃ©seau (TCP) :

* `send_json(sock, obj)` : envoie un dictionnaire Python transformÃ© en JSON (pour transfÃ©rer les clÃ©s publiques, messages, etc.).
* `recv_json(sock)` : lit et decode le JSON reÃ§u.

Ã‡a Ã©vite de rÃ©Ã©crire la mÃªme chose dans Alice et Bob.

---

## 3. CÃ´tÃ© Alice

### 3.1. `alice/alice_keys.py`

RÃ´le : **gÃ©nÃ©rer et stocker** les clÃ©s dâ€™Alice dans deux fichiers sÃ©parÃ©s.

* utilise `generate_keys()` de `rsa_core.py`
* Ã©crit :

  * `alice_public.key` : texte avec `n` et `e`
  * `alice_private.key` : texte avec `n` et `u`

Format trÃ¨s simple par ex. :

```text
# alice_public.key
n=5141
e=7

# alice_private.key
n=5141
u=4279
```

### 3.2. `alice/alice_encrypt.py`

RÃ´le : regrouper les fonctions utiles pour les programmes client/serveur dâ€™Alice :

* `load_public_key(path)` â†’ lit `n`, `e` depuis un fichier
* `load_private_key(path)` â†’ lit `n`, `u`
* `encrypt_message(message, n, e)`
* `decrypt_message(cipher_list, n, u)`

### 3.3. `alice/alice_server.py`

RÃ´le : Alice Ã©coute sur un port pour recevoir un message chiffrÃ© de Bob.

ScÃ©nario typique :

1. Charge **sa propre clÃ© privÃ©e** (`alice_private.key`) pour dÃ©chiffrer.
2. Ouvre un socket TCP serveur : `bind( ('0.0.0.0', PORT_ALICE) )`, `listen()`, `accept()`.
3. ReÃ§oit dâ€™abord la clÃ© publique de Bob (ou pas, selon ton protocole).
4. ReÃ§oit un message chiffrÃ© (liste dâ€™entiers).
5. DÃ©chiffre avec `decrypt_message` et affiche le texte.

### 3.4. `alice/alice_client.py`

RÃ´le : envoyer un message Ã  Bob (Bob a un serveur qui Ã©coute).

ScÃ©nario typique :

1. Charge la **clÃ© publique de Bob** (fichier `bob_public.key` COPIÃ‰ sur la machine dâ€™Alice).
2. Demande Ã  lâ€™utilisateur : `input("Message Ã  envoyer Ã  Bob : ")`.
3. Chiffre le message avec la clÃ© publique de Bob.
4. Se connecte au serveur de Bob (`socket`, `connect((ip_bob, PORT_BOB))`).
5. Envoie la liste chiffrÃ©e via `send_json`.

---

## 4. CÃ´tÃ© Bob

Exactement la mÃªme logique, mais dans le dossier `bob/`.

### 4.1. `bob/bob_keys.py`

GÃ©nÃ¨re et Ã©crit `bob_public.key` et `bob_private.key`.

### 4.2. `bob/bob_encrypt.py`

Les mÃªmes fonctions que pour Alice (`load_public_key`, `encrypt_message`, etc.)
Tu peux mÃªme rÃ©utiliser le mÃªme code et juste changer les noms de fichiers.

### 4.3. `bob/bob_server.py`

Bob Ã©coute sur un port pour recevoir des messages dâ€™Alice.
Structure miroir de `alice_server.py`.

### 4.4. `bob/bob_client.py`

Bob peut aussi envoyer des messages Ã  Alice.
Structure miroir de `alice_client.py`.

---

## 5. ScÃ©nario complet (comment tu lâ€™utilises en vrai)

1. Sur le **PC dâ€™Alice**

   * lancer `alice_keys.py` â†’ crÃ©e `alice_public.key`, `alice_private.key`.

2. Sur le **PC de Bob**

   * lancer `bob_keys.py` â†’ crÃ©e `bob_public.key`, `bob_private.key`.

3. **Ã‰change de clÃ©s publiques**

   * copier `alice_public.key` sur le PC de Bob (dans `bob/` par ex.)
   * copier `bob_public.key` sur le PC dâ€™Alice (dans `alice/`)

4. Pour que **Bob reÃ§oive** un message :

   * sur Bob : lancer `bob_server.py` (il attend sur un port).
   * sur Alice : lancer `alice_client.py`, taper un message, il est chiffrÃ© et envoyÃ©.

5. Pour que **Alice reÃ§oive** :

   * sur Alice : lancer `alice_server.py`.
   * sur Bob : lancer `bob_client.py`.

Ainsi :

* chacun a **son fichier de clÃ© privÃ©e**, **son fichier de clÃ© publique**,
* chacun a **ses scripts de chiffrement/dÃ©chiffrement**,
* ils se parlent par **client/serveur TCP**.

---

## 6. Prochaine Ã©tape

Maintenant quâ€™on a la **structure claire**, je peux :

* soit te donner **tout le code de `common/rsa_core.py` + les scripts de clÃ©s (alice_keys/bob_keys)**,
* soit commencer par **un cÃ´tÃ© (par ex. Bob serveur, Alice client)** pour que tu testes rapidement puis dupliques.

Dis-moi ce que tu prÃ©fÃ¨res que je code en premier :
â¡ï¸ le **cÅ“ur RSA (`rsa_core.py` + `alice_keys.py` + `bob_keys.py`)**
ou directement un cÃ´tÃ© **Bob serveur / Alice client** prÃªt Ã  exÃ©cuter ?
Je pars du principe que tu as **2 vrais PC diffÃ©rents** sur le mÃªme rÃ©seau (Wi-Fi/ethernet), avec Python installÃ© sur les deux.
On va voir :

1. **La structure des fichiers sur chaque PC**
2. **OÃ¹ mettre la comparaison du message reÃ§u / message original** 

---

## 1ï¸âƒ£ Structure cÃ´tÃ© *Alice* (PC 1)

Sur le PC dâ€™Alice, tu peux avoir un dossier, par exemple :

```text
C:\rsa_alice\      (ou /home/alice/rsa_alice/)
â”‚
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ rsa_core.py        # RSA (gÃ©nÃ©ration clÃ©s, chiffrement, dÃ©chiffrement)
â”‚   â””â”€â”€ net_utils.py       # fonctions d'envoi/rÃ©ception (JSON, etc.)
â”‚
â””â”€â”€ alice/
    â”œâ”€â”€ alice_keys.py      # gÃ©nÃ¨re les clÃ©s dâ€™Alice et les enregistre dans des fichiers
    â”œâ”€â”€ alice_client.py    # envoie un message Ã  Bob (client TCP)
    â”œâ”€â”€ alice_server.py    # reÃ§oit un message de Bob (serveur TCP, optionnel)
    â”œâ”€â”€ alice_crypto.py    # utilise rsa_core + charge/sauve les clÃ©s
    â”œâ”€â”€ alice_public.key   # fichier texte contenant (n, e) d'Alice
    â”œâ”€â”€ alice_private.key  # fichier texte contenant (n, u) d'Alice
    â””â”€â”€ bob_public.key     # copie de la clÃ© publique de Bob (pour chiffrer vers Bob)
```

ğŸ‘‰ Sur le PC dâ€™Alice, **elle doit possÃ©der** :

* **sa clÃ© privÃ©e** `alice_private.key` (ne sort jamais de son PC)
* **sa clÃ© publique** `alice_public.key` (peut Ãªtre copiÃ©e)
* **la clÃ© publique de Bob** `bob_public.key` (copiÃ©e depuis le PC de Bob)

---

## 2ï¸âƒ£ Structure cÃ´tÃ© *Bob* (PC 2)

Sur le PC de Bob, mÃªme idÃ©e, mais dossier diffÃ©rent :

```text
C:\rsa_bob\       (ou /home/bob/rsa_bob/)
â”‚
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ rsa_core.py        # mÃªme fichier que chez Alice, copiÃ© tel quel
â”‚   â””â”€â”€ net_utils.py
â”‚
â””â”€â”€ bob/
    â”œâ”€â”€ bob_keys.py        # gÃ©nÃ¨re les clÃ©s de Bob
    â”œâ”€â”€ bob_server.py      # reÃ§oit le message dâ€™Alice (serveur TCP)
    â”œâ”€â”€ bob_client.py      # envoie un message Ã  Alice (client TCP, optionnel)
    â”œâ”€â”€ bob_crypto.py      # utilise rsa_core + charge/sauve les clÃ©s
    â”œâ”€â”€ bob_public.key     # fichier texte (n, e) de Bob
    â”œâ”€â”€ bob_private.key    # fichier texte (n, u) de Bob
    â””â”€â”€ alice_public.key   # copie de la clÃ© publique dâ€™Alice (pour chiffrer vers Alice)
```

ğŸ‘‰ Sur le PC de Bob, **il doit possÃ©der** :

* **sa clÃ© privÃ©e** `bob_private.key`
* **sa clÃ© publique** `bob_public.key`
* **la clÃ© publique dâ€™Alice** `alice_public.key`

---

## 3ï¸âƒ£ Comment se passe lâ€™Ã©change rÃ©seau ?

On prend un scÃ©nario simple :
â¡ï¸ **Alice envoie un message Ã  Bob** (Bob a un serveur, Alice un client).

### Ã‰tape 0 â€” GÃ©nÃ©ration des clÃ©s (hors ligne)

* Sur Alice : `python alice/alice_keys.py`
  â†’ crÃ©e `alice_public.key`, `alice_private.key`
* Sur Bob : `python bob/bob_keys.py`
  â†’ crÃ©e `bob_public.key`, `bob_private.key`

Ensuite, tu **Ã©changes seulement les fichiers publics** :

* tu copies `alice_public.key` â†’ sur le PC de Bob (dans `bob/`)
* tu copies `bob_public.key` â†’ sur le PC dâ€™Alice (dans `alice/`)

Les fichiers `*_private.key` restent chacun sur leur machine.

---

### Ã‰tape 1 â€” Bob attend les messages

Sur le PC de Bob :

```bash
python bob/bob_server.py
```

* Il fait un `socket.bind(("0.0.0.0", PORT_BOB))`, `listen()`, `accept()`.
* Il reÃ§oit :

  * soit le message chiffrÃ©
  * soit un petit JSON `{ "cipher": [ ... ] }`

Il utilise alors `bob_crypto.py` + `bob_private.key` pour **dÃ©chiffrer**.

---

### Ã‰tape 2 â€” Alice envoie le message

Sur le PC dâ€™Alice :

```bash
python alice/alice_client.py
```

Ce script :

1. lit `bob_public.key`

2. demande Ã  lâ€™utilisateur :

   ```text
   Entrez le message Ã  envoyer : 
   ```

3. convertit le texte â†’ liste dâ€™entiers ASCII (comme dans le PDF)

4. chiffre chaque entier avec `(n_bob, e_bob)`

5. envoie le tout via TCP au serveur de Bob (`ip_de_bob`, `PORT_BOB`)

---

## 4ï¸âƒ£ OÃ¹ on compare le message reÃ§u / message original ?

Tu as deux possibilitÃ©s, Ã  toi de choisir selon ce que veut le prof :

---

### âœ… Variante A : comparaison **visuelle** (simple)

* Sur Alice : tu affiches `Message envoyÃ© : <texte>`.
* Sur Bob : tu affiches `Message reÃ§u (dÃ©chiffrÃ©) : <texte>`.

Le prof voit que le message reÃ§u est identique au message envoyÃ© â†’ OK.

---

### âœ… Variante B : comparaison **automatique** de bout en bout

LÃ  on fait un aller-retour pour **vÃ©rifier automatiquement** :

1. Alice envoie un message **M** Ã  Bob (chiffrÃ© avec la clÃ© publique de Bob).
2. Bob dÃ©chiffre â†’ obtient **M'**.
3. Bob **rÃ©-envoie M'** Ã  Alice, mais cette fois **chiffrÃ© avec la clÃ© publique dâ€™Alice**.
4. Alice dÃ©chiffre â†’ obtient **M''**.
5. Alice compare :

```python
if M == M_double_prime:
    print("âœ… Message intact, chiffrement/dÃ©chiffrement OK.")
else:
    print("âŒ Erreur : le message final est diffÃ©rent.")
```

Dans cette variante :

* `bob_server.py` : reÃ§oit, dÃ©chiffre, affiche & renvoie.
* `alice_client.py` : en plus dâ€™envoyer, il **attend une rÃ©ponse**, la dÃ©chiffre avec `alice_private.key`, puis compare au message original.

Câ€™est typiquement le genre de truc que les enseignants aiment bien, car Ã§a **prouve** que toute la chaÃ®ne (rÃ©seau + RSA) fonctionne.

---

## 5ï¸âƒ£ RÃ©sumÃ© ultra court

* **PC Alice** : dossier `rsa_alice/` avec `common/` + `alice/`
* **PC Bob**   : dossier `rsa_bob/`   avec `common/` + `bob/`
* ClÃ©s :

  * chaque PC garde **sa clÃ© privÃ©e**, Ã©change seulement la **clÃ© publique**.
* RÃ©seau :

  * Bob lance `bob_server.py`
  * Alice lance `alice_client.py`
* Comparaison :

  * soit **Ã  lâ€™Å“il** (messages affichÃ©s),
  * soit par **aller-retour** avec un `if message_original == message_recu:` cÃ´tÃ© Alice.

---

Si tu veux, au prochain message je peux commencer Ã  te donner **les vrais fichiers Python**, par ex :

1. `common/rsa_core.py`
2. `alice/alice_keys.py` + `bob/bob_keys.py`

pour que tu puisses dÃ©jÃ  gÃ©nÃ©rer des clÃ©s sur les deux machines.
